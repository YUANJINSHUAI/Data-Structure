find 5!
5! = 1*2*3*4*5 = 120

1. An iterative Algorithm

def getFactorical(5)
  focorial = 1
    for x = 1 to 5:
      factorial = factorial * x

2. A Recursive Algorithm
def getFactorical(n)
  if n < 2:
    return 1
  else:
    return n*getFactorical(n-1)
 
  '''
  以下是问题代码
  '''
  class Solution(object):
    def maxDepth(self, root):
        depth = 0       # 这个depth删掉，我们用递归的次数，代替depth，在最后r1和r2上加上1 + return（相当于返回的值，类似于depth = depth + 1的意思）
        if root is None:
            return depth 
        # 问题说明：接下来的是判断root的下一个节点是不是都为空的节点
        depth = depth  + 1 # 这里应该在这之前加上 if root is not None:
        while root.left is None and root.right is None: # 后面的都不要了
            depth = depth
            return depth
        else:            
            if root.left is not None:
                root_1 = root.left  
            else:
                root_1 = root
            if root.right is not None:
                root_2 = root.right
            else:
                root_2 = root
            depth = depth + 1
            r1 = self.maxDepth(root_1) # 应该改成 r1 = self.maxDepth(root.left) 首先看看root.left是否为空
            r2 = self.maxDepth(root_2) # 应该改成 r2 = self.maxDepth(root.right) 首先看看root.right是否为空
        
        return r1, r2 
    
    '''
    以下为正确代码
    '''
    class Solution(object):
    def maxDepth(self, root):
        if root is None:
            return 0 
        if root is not None:       
            r1 = 1 + self.maxDepth(root.left) 
            r2 = 1 + self.maxDepth(root.right) 
        return max(r1, r2)
 
 '''
 递归的另一个例子——二叉树的插入
 '''
 def insert(self, data):
    if self.data is not None:
        if data >= self.data:
            if self.left is not None:
                 self.left.insert(data) # 如果要插入的节点存在数据，则要将这个节点看成根节点，在执行一下insert;这个子节点和父节点做的事情是一样的
            else:
                self.left = Node(data)
        else:
             if self.right is not None:
                 self.right.insert(data)
             else:
                 self.right = None(data)
    else:
        self.data = data
 
'''
递归的一个例子——打印树
'''
 # Print the tree
    def PrintTree(self):
        if self.left is not None:
            self.left.PrintTree() # 如果子树存在的话，那么打印的动作和父树相同，所以这个地方可以用递归
        print(self.data)
        if self.right is not None:
            self.right.PrintTree()
